defmodule Frac5.Transforms do
  @moduledoc """
  This module contains a selection of transformations on points which
  may be interesting for generating Frac5 images, as well as the essential
  `points_stream` function, which accepts a `Stream` of transformations on
  `Nx.Tensor` points, an initial `Nx.Tensor` of points (these two may be
  generated by `Frac5.Affine.generate_stream_init()`), and a list of
  transformations to be applied in parallel, and generates a `Stream` of
  `5D` point tensors, which can be truncated and reduced to form an image.
  """
  import Nx.Defn

  @pi2 2.0 * :math.acos(-1.0)
  @pi4 2.0 * @pi2
  @doc """
  Performs the transformation `x_i -> x_i + (Sum_j x_j*x_j)^0.25`, with
  coordinates wrapped around periodically to the range `[-2*PI, 2*PI]`
  """
  defn expand(pts) do
    s2 = Nx.sum(pts * pts, axes: [-1], keep_axes: true)
    Nx.remainder(pts + Nx.pow(s2, 0.25) + @pi2, @pi4) - @pi2
  end

  @doc """
  Performs the transformation `x_i -> x_i * (Sum_j x_j*x_j)^-0.33`
  """
  defn contract(pts) do
    s2 = Nx.sum(pts * pts, axes: [-1], keep_axes: true)
    pts * Nx.pow(s2, -0.33)
  end

  @doc """
  Averages each pair of successive points in the input, to generate the output.
  """
  defn wmean(pts) do
    Nx.window_mean(pts, {2, 1}, padding: :same)
  end

  @doc """
  Performs the transform `x_i -> 2 * sin(x_i)`
  """
  defn sin2(pts) do
    2.0 * Nx.sin(pts)
  end

  @doc """
  The default parallel transforms are `expand`, `contract`, and `Nx.cos`.
  """
  def default_parallels() do
    [&expand/1, &contract/1, &Nx.cos/1]
  end

  @chunk_limit 100_000
  @doc """
  Accepts a `txform_stream` and `init_points` tensor, as may be
  generated by `Frac5.Affine.generate_stream_init()`, and a list of
  parallel transforms, as for example those provided by
  `default_parallels()`, and generates a stream of 5D point batch
  tensors, which can be truncated and reduced to form an image.
  """
  def points_stream(txform_stream, init_points, parallels) do
    Stream.transform(txform_stream, [init_points], fn txform, pts_stream ->
      next_stream =
        Stream.flat_map(pts_stream, fn pts ->
          {n, _} = Nx.shape(pts)

          if n >= @chunk_limit do
            Enum.map(parallels, fn par -> txform.(par.(pts)) end)
          else
            ppts =
              Enum.map(parallels, fn par -> par.(pts) end)
              |> Nx.concatenate()

            [txform.(ppts)]
          end
        end)

      {next_stream, next_stream}
    end)
  end
end
